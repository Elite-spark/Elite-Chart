<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Elite Spark - Live & Memory</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', sans-serif; }
        #chart { width: 100vw; height: 100vh; z-index: 1; }
        
        /* ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑŸáŸàŸäÿ© ÿßŸÑÿ®ÿµÿ±Ÿäÿ© */
        .brand-container {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #FFD700; pointer-events: none;
            display: flex; flex-direction: column; align-items: center;
        }
        .brand-container h1 { margin: 0; font-size: 18px; letter-spacing: 2px; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
        .brand-container p { margin: 2px 0; font-size: 12px; opacity: 0.8; }
        .user-logo { width: 45px; height: 45px; margin-top: 8px; border: 0px solid #FFD700; border-radius: 1px; }

        #countdown-box {
            position: absolute; top: 20px; right: 80px; z-index: 10;
            display: flex; flex-direction: column; align-items: center;
            background: rgba(20, 20, 20, 0.8); border: 1px solid #FFD700;
            padding: 5px 12px; border-radius: 8px; min-width: 60px;
        }
        #countdown-label { color: #FFD700; font-size: 9px; text-transform: uppercase; margin-bottom: 2px; }
        #countdown { color: #FFD700; font-weight: bold; font-size: 16px; font-family: 'Courier New', monospace; }

        .timeframes {
            position: absolute; bottom: 30px; left: 20px;
            z-index: 20; display: flex; gap: 10px;
        }
        .tf-btn {
            background: #000; border: 1px solid #FFD700; color: #FFD700;
            padding: 6px 15px; border-radius: 6px; cursor: pointer; font-size: 12px; transition: 0.3s;
        }
        .tf-btn.active { background: #FFD700; color: #000; font-weight: bold; }

        /* [NEW: UI] ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿ®ÿßŸÑÿ±ÿ≥ŸÖ */
        .drawing-controls {
            position: absolute; top: 22px; right: 180px; z-index: 20;
            display: flex; flex-direction: row; gap: 10px;
        }
        .draw-btn {
            background: rgba(0,0,0,0.6); border: 1px solid #FFD700; color: #FFD700;
            width: 40px; height: 40px; border-radius: 5px; cursor: pointer; font-size: 18px;
        }
        .draw-btn.active { background: #FFD700; color: #000; }
    </style>
</head>
<body>
    
    <div id="countdown-box">
        <div id="countdown-label">Next Candle</div>
        <div id="countdown">00:00</div>
    </div>
    
    <div class="brand-container">
        <h1>ELITE SPARK</h1>
        <p>XAU/USD - GOLD LIVE</p>
        <img src="https://i.ibb.co/R4kwHrMc/image.png" class="user-logo" alt="Logo">
    </div>

    <div class="drawing-controls">
        <button class="draw-btn" title="ÿ±ÿ≥ŸÖ ÿÆÿ∑ ÿ£ŸÅŸÇŸä" onclick="addPriceLine()">‚ûï</button>
        <button class="draw-btn" style="color:red" title="ŸÖÿ≥ÿ≠ ÿßŸÑŸÉŸÑ" onclick="clearAllDrawings()">üóëÔ∏è</button>
    </div>

    <div class="timeframes">
        <button class="tf-btn" onclick="changeTf('1m', this)">1M</button>
        <button class="tf-btn" onclick="changeTf('5m', this)">5M</button>
        <button class="tf-btn active" onclick="changeTf('15m', this)">15M</button>
    </div>

    <div id="chart"></div>

    <script>
        let currentInterval = '15m';
        let countdownTimer;
        let socket; // [NEW: SOCKET VARIABLE]

        const chart = LightweightCharts.createChart(document.getElementById('chart'), {
            layout: { background: { color: '#000000' }, textColor: '#FFD700' },
            grid: { vertLines: { visible: false }, horzLines: { visible: false } },
            crosshair: { 
                mode: LightweightCharts.CrosshairMode.Normal,
                vertLine: { color: '#FFD700', labelBackgroundColor: '#000' },
                horzLine: { color: '#FFD700', labelBackgroundColor: '#000' }
            },
            rightPriceScale: { borderColor: '#FFD700' },
            timeScale: { borderColor: '#FFD700', timeVisible: true }
        });

        const candleSeries = chart.addCandlestickSeries({
            upColor: '#FFD700', downColor: '#000',
            borderUpColor: '#FFD700', borderDownColor: '#FFD700',
            wickUpColor: '#FFD700', wickDownColor: '#FFD700'
        });

        // [NEW: DRAWING STORAGE] ŸÜÿ∏ÿßŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ±ÿ≥ŸàŸÖ
        let savedLines = JSON.parse(localStorage.getItem('elite_drawings') || '[]');

        function loadSavedLines() {
            savedLines.forEach(price => {
                candleSeries.createPriceLine({
                    price: price, color: '#FFD700', lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true
                });
            });
        }

        async function updateChartData(interval) {
            try {
                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=PAXGUSDT&interval=${interval}&limit=500`);
                const rawData = await response.json();
                const data = rawData.map(d => ({
                    time: d[0] / 1000, open: parseFloat(d[1]), high: parseFloat(d[2]),
                    low: parseFloat(d[3]), close: parseFloat(d[4])
                }));
                candleSeries.setData(data);
                setupCountdown(interval);
                connectSocket(interval); // [NEW: CALL SOCKET]
                loadSavedLines(); // [NEW: LOAD DRAWINGS]
            } catch (e) { console.error(e); }
        }

        // [NEW: LIVE UPDATE] ÿ±ÿ®ÿ∑ ÿßŸÑÿ®ÿ´ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ± ŸÑŸÑÿ¥ŸÖÿπÿ©
        function connectSocket(interval) {
            if (socket) socket.close();
            socket = new WebSocket(`wss://stream.binance.com:9443/ws/paxgusdt@kline_${interval}`);
            socket.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                const k = msg.k;
                candleSeries.update({
                    time: k.t / 1000,
                    open: parseFloat(k.o), high: parseFloat(k.h),
                    low: parseFloat(k.l), close: parseFloat(k.c)
                });
            };
        }

        // [NEW: DRAWING LOGIC] ÿ•ÿ∂ÿßŸÅÿ© ÿÆÿ∑Ÿàÿ∑ Ÿàÿ≠ŸÅÿ∏Ÿáÿß
        function addPriceLine() {
            const data = candleSeries.data();
            if (data.length === 0) return;
            const finalPrice = data[data.length - 1].close;

            candleSeries.createPriceLine({
                price: finalPrice, color: '#FFD700', lineWidth: 2,
                lineStyle: LightweightCharts.LineStyle.Dashed,
                axisLabelVisible: true, title: 'ELITE LEVEL'
            });

            savedLines.push(finalPrice);
            localStorage.setItem('elite_drawings', JSON.stringify(savedLines));
        }

        function clearAllDrawings() {
            if(confirm("ŸáŸÑ ÿ™ÿ±ŸäÿØ ŸÖÿ≥ÿ≠ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ±ÿ≥ŸàŸÖÿü")) {
                localStorage.removeItem('elite_drawings');
                location.reload();
            }
        }

        function setupCountdown(interval) {
            if (countdownTimer) clearInterval(countdownTimer);
            const minutes = parseInt(interval);
            const intervalMs = minutes * 60 * 1000;
            countdownTimer = setInterval(() => {
                const now = new Date().getTime();
                const timeLeft = intervalMs - (now % intervalMs);
                const m = Math.floor(timeLeft / 60000);
                const s = Math.floor((timeLeft % 60000) / 1000);
                document.getElementById('countdown').innerText = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }, 1000);
        }

        function changeTf(tf, btn) {
            currentInterval = tf;
            document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            updateChartData(tf);
        }

        updateChartData(currentInterval);
        window.onresize = () => chart.applyOptions({ width: window.innerWidth, height: window.innerHeight });
    </script>
</body>
</html>
